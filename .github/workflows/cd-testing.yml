name: CD - Deploy to Testing Environment

on:
  workflow_run:
    workflows: ["CD - Build, Test & Push Image"]
    types:
      - completed
    branches:
      - main
  workflow_dispatch:
    inputs:
      image-tag:
        description: 'Image tag to deploy (default: latest)'
        required: false
        default: 'latest'

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: espectaculos-api
  ECS_CLUSTER: espectaculos-testing
  ECS_SERVICE: espectaculos-api-service
  CONTAINER_NAME: espectaculos-api
  AWS_ACCOUNT_ID: ${{ secrets.AWS_ACCOUNT_ID }}
  AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  AWS_SESSION_TOKEN: ${{ secrets.AWS_SESSION_TOKEN }}

jobs:
  deploy-testing:
    name: Deploy to Testing
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    permissions:
      contents: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials (access keys session)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ env.AWS_SESSION_TOKEN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Get ECR login token
        run: |
          aws ecr get-authorization-token --region ${{ env.AWS_REGION }} | \
          docker login --username AWS --password-stdin ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com
        shell: bash

      - name: Get image tag from workflow
        id: image-tag
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            TAG="${{ github.event.inputs.image-tag }}"
          else
            TAG="latest"
          fi
          echo "tag=${TAG}" >> $GITHUB_OUTPUT
        shell: bash

      - name: Check container image exists in ECR
        run: |
          aws ecr describe-images \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-ids imageTag=${{ steps.image-tag.outputs.tag }} \
            --region ${{ env.AWS_REGION }} || exit 1
        shell: bash

      - name: Create ECS task definition
        id: task-def
        run: |
          # Descargar task definition actual
          TASK_DEF=$(aws ecs describe-task-definition \
            --task-definition espectaculos-api-task \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition' || echo '{}')
          
          # Actualizar imagen
          UPDATED_TASK_DEF=$(echo "${TASK_DEF}" | jq \
            --arg IMAGE "${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}" \
            '.containerDefinitions[0].image = $IMAGE | del(.taskDefinitionArn) | del(.revision) | del(.status) | del(.requiresAttributes)')
          
          echo "${UPDATED_TASK_DEF}" > task-definition.json
          echo "task-def-arn=$(echo ${TASK_DEF} | jq -r '.taskDefinitionArn')" >> $GITHUB_OUTPUT
        shell: bash
        continue-on-error: true

      - name: Register new ECS task definition
        id: register-task
        run: |
          TASK_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://task-definition.json \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "task-arn=${TASK_ARN}" >> $GITHUB_OUTPUT
        shell: bash
        continue-on-error: true

      - name: Update ECS service
        if: steps.register-task.outcome == 'success'
        run: |
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition ${{ steps.register-task.outputs.task-arn }} \
            --region ${{ env.AWS_REGION }} \
            --force-new-deployment
        shell: bash

      - name: Wait for service to stabilize
        if: steps.register-task.outcome == 'success'
        run: |
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}
        shell: bash
        continue-on-error: true

      - name: Verify deployment
        run: |
          DEPLOYMENT=$(aws ecs describe-services \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --query 'services[0]' --output json)
          
          echo "Service Status:"
          echo "${DEPLOYMENT}" | jq '.status'
          echo ""
          echo "Running Tasks:"
          echo "${DEPLOYMENT}" | jq '.runningCount'
          echo ""
          echo "Desired Tasks:"
          echo "${DEPLOYMENT}" | jq '.desiredCount'
        shell: bash

      - name: Post deployment summary
        run: |
          echo "## ðŸš€ Deployment Summary"
          echo ""
          echo "**Environment:** Testing"
          echo "**Image:** ${{ env.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ steps.image-tag.outputs.tag }}"
          echo "**Cluster:** ${{ env.ECS_CLUSTER }}"
          echo "**Service:** ${{ env.ECS_SERVICE }}"
          echo ""
          echo "The deployment has been initiated. Check CloudWatch logs for detailed deployment status."
        shell: bash

  health-check:
    name: Health Check
    runs-on: ubuntu-latest
    needs: deploy-testing
    if: success()
    
    steps:
      - name: Wait for service to be ready
        run: sleep 30
        shell: bash

      - name: Health check endpoint
        run: |
          RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" https://api-testing.example.com/health)
          if [ "$RESPONSE" == "200" ]; then
            echo "âœ… Health check passed"
          else
            echo "âš ï¸ Health check returned: $RESPONSE"
          fi
        shell: bash
        continue-on-error: true

  smoke-tests:
    name: Run Smoke Tests
    runs-on: ubuntu-latest
    needs: health-check
    if: success()
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v3
        with:
          dotnet-version: '8.0.x'

      - name: Run smoke tests against testing environment
        run: |
          # Ejecutar pruebas de humo contra el entorno de testing
          # Esto requerirÃ­a un proyecto de pruebas configurado
          echo "Running smoke tests against testing environment..."
          echo "API Endpoint: https://api-testing.example.com"
        shell: bash
        continue-on-error: true

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [deploy-testing, health-check, smoke-tests]
    if: always()
    
    steps:
      - name: Determine status
        id: status
        run: |
          if [ "${{ needs.deploy-testing.result }}" == "success" ] && \
             [ "${{ needs.health-check.result }}" == "success" ]; then
            echo "status=âœ… Deployment successful" >> $GITHUB_OUTPUT
          else
            echo "status=âŒ Deployment failed" >> $GITHUB_OUTPUT
          fi
        shell: bash
